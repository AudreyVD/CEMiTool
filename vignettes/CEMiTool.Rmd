---
title: "CEMiTool: Co-expression Modules Identification Tool"
output: 
  prettydoc::html_pretty:
    toc: true
    theme: cayman
    highlight: github
  pdf_document:
    toc: true
vignette: >
  %\VignetteIndexEntry{CEMiTool: Co-expression Modules Identification Tool}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---


```{r style, echo=FALSE, results="asis", message=FALSE}
knitr::opts_chunk$set(tidy = FALSE,
                      warning = FALSE,
                      message = FALSE)
```

# Basic usage

The `CEMiTool` `R` package provides users with an easy-to-use method to automatically
implement `WGCNA` analyses with optimized parameters, gene set enrichment analysis and
overrepresentation analysis.

In order to use `CEMiTool`, you only need a data.frame containing expression data,
with gene symbols in the rows and sample names in the columns, as following:

```{r}

library("CEMiTool")

# Load expression data
data(expr)
head(expr[,1:4])
```

The `cemitool` function receives the expression data and returns a `CEMiTool` object:
```{r}
cem <- cemitool(expr)
```

To see what's inside of the `CEMiTool` object we can use `print`:
```{r}
print(cem)
```

There are `r nmodules(cem)` modules and the relation between genes and modules can be seen in `cem@module` slot:
```{r}
head(cem@module)
```

As more information is included in CEMiTool a more complete object can be built and richer reports can be provided.

For instance, we can provide a sample annotation `data.frame` specifying a class for each sample. Classes can represent, for example, different conditions, phenotypes, cell lines, time points, etc. In this example, classes are defined as samples obtained on the same time points, where "g0" represents samples obtained at the beginning of the experiment, time point 0. 

```{r}
# Load your sample annotation data
data(sample_annot)

head(sample_annot)
```

And then generate a report:
```{r, echo=FALSE}
generate_report(cem)
```

The report will be in the directory `./reports`.


...

```{r}
ncores <- parallel::detectCores()
doParallel::registerDoParallel(cores=ncores)
```

```{r}
# Reading GMT file
gmt_fname <- system.file("extdata", "pathways.gmt", package = "CEMiTool")
gmt_in <- read_gmt(gmt_fname)
```

```{r}
# Reading interactions
int_fname <- system.file("extdata", "interactions.tsv", package = "CEMiTool")
int_df <- read.delim(int_fname)
```

```{r}
# running cemitool
cem <- cemitool(expr, sample_annot, gmt_in, interactions=int_df, 
                filter=F, plot=T, split_modules=T)
```

```{r}
generate_report(cem)
```


```{r}
write_files(cem, directory="./reports", force=T)
```

```{r}
# create a new CEMiTool object
cem <- new("CEMiTool", expression=expr, 
               sample_annotation=sample_annot)
```

```{r}
# Find the modules
cem <- find_modules(cem) 
```

```{r}
# If you desire, split the modules by positive and negative correlation
cem <- split_modules(cem)
```

```{r}
# Take a look at the expression patterns of those modules.
# You can also use the gene_module variable here.
cem <- plot_profile(cem)
print(cem@profile_plot[[1]])
```

```{r}
# Now that you got the modules, why don't you just give a look
# at the enrichment of those modules in your experimental classes
cem <- mod_gsea(cem)
```

```{r}
# Heatmap of gene set enrichment analysis
cem <- plot_gsea(cem)
print(cem@enrichment_plot)
```

```{r}
# Performs over representation analysis
cem <- mod_ora(cem, gmt_in)
```

```{r}
# plot ora results
cem <- plot_ora(cem)
print(cem@barplot_ora[[1]][["pl"]])
```

```{r}
# adds interaction
cem <- include_interactions(cem, int_df)
```

```{r}
# plot interactions
cem <- plot_interactions(cem)
```

```{r results="hide"}
# generate report
generate_report(cem)
generate_report(cem, output_format=c("pdf_document", "html_document"))
```

