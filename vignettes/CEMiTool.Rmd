




---
title: "CEMiTool: Co-expression Modules Identification Tool"
output: 
  prettydoc::html_pretty:
    toc: true
    theme: cayman
    highlight: github
  pdf_document:
    toc: true
vignette: >
  %\VignetteIndexEntry{CEMiTool: Co-expression Modules Identification Tool}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---


```{r style, echo=FALSE, results="asis", message=FALSE}
knitr::opts_chunk$set(tidy = FALSE,
                      warning = FALSE,
                      message = FALSE,
                      cache=TRUE)
```

# Theory








# Basic usage

The `CEMiTool` `R` package provides users with an easy-to-use method to automatically
implement `WGCNA` analyses with optimized parameters. It also performs gene set enrichment analysis and
overrepresentation analysis.

For the most basic usage of `CEMiTool` you only need a data.frame containing expression data,
with gene symbols in the rows and sample names in the columns, as following:

```{r}

library("CEMiTool")

# Load expression data
data(expr)
head(expr[,1:4])
```

The `cemitool` function receives the expression data and returns a `CEMiTool` object:
```{r, results='hide'}
cem <- cemitool(expr)
```

To see a summary of the slots inside the `CEMiTool` object we can use `print`. 
```{r}
print(cem)
```

The slots can be accessed with  `cem@`. The WGCNA analysis has produced `r nmodules(cem)` modules and the allocation of genes to modules can be seen in `cem@module` slot:

```{r}
nmodules(cem)
head(cem@module)
```

Genes that are allocated to `Not.Correlated` are genes that are not clustered into any module.


If you wish to adjust the the module definition parameters of your `CEMiTool` object, use `find_modules(cem, ...)`.

 
## Gene filtering

As a default, the `cemitool` function  performs a filtering of the gene expression data before running the `WGCNA` analysis. This filtering is done in accordance to gene variance (more information in section.). In this example the filtering step has reduced the gene number to `r length(cem@selected_genes)`.

If you wish to change the filtering parameters on a `CEMiTool` object, use the `filter_exp(cem, ...)` function.





## Generating reports


The information generated by CEMiTool can be accessed by generating a report of a the `CEMiTool` object:


```{r, eval=FALSE}

generate_report(cem)
```

The report will written to the directory `./reports`.



## Adding sample annotation


More information can be included in CEMiTool to build a more complete object and generate richer reports about the expression data. Sample annotation can be supplied in a `data.frame` that specifies a class for each sample. Classes can represent different conditions, phenotypes, cell lines, time points, etc. In this example, classes are defined as samples obtained at a given time point.

```{r}
# Load your sample annotation data
data(sample_annot)
head(sample_annot)
```
Now you can construct a `CEMiTool` object with both expression data and sample annotation:

```{r, results='hide'}

cem <- cemitool(expr,sample_annot)
```

The sample annotation of your CEMiTool object can be retrieved and reassinged using the `sample_annotation` function.


## Module enrichment
When sample annotation is provided, the `cemitool` function will automatically evaluate how the modules are up or down regulated between classes. This is performed using the gene set enrichment analysis function from the `fgsea` package. 


You can generate a heatmap of how the enrichment of the modules varies across classes with the `plot_gsea` function, and display with `cem@enrichment_plot`. The size and intensity of the cirlces in the heatmap correspond to the Normalised Enrichment Score (NES), which is the enrichment score for a module in each class normalised by the size of the gene set.
```{r}
# Heatmap of gene set enrichment analysis
cem <- plot_gsea(cem)
print(cem@enrichment_plot)
```

You can also peform GSEA analysis on the modules in your `CEMiTool` object using the `mod_gsea` function:
```{r}
#Perform GSEA of modules across your experimental classes
cem <- mod_gsea(cem)
```

## Expression patterns in modules

You can generate a plot that displays the expression of each gene within a module using the `plot_profile` function:


```{r}
cem <- plot_profile(cem)
print(cem@profile_plot[[1]])
```

## Adding ORA analysis

CEMiTool can determine which biological functions are associated with the modules by performing an over representation analysis. To do this you must provide a pathway list in the form of gmt file. CEMiTool will then use the `clusterProfiler` package to see how these patways are represented in the modules.

You can read in a pathway list formatted as a gmt file using the  `read_gmt` function. This example uses a gmt that is part of the `CEMiTool` example data:

```{r}
# Reading GMT file
gmt_fname <- system.file("extdata", "pathways.gmt", package = "CEMiTool")
gmt_in <- read_gmt(gmt_fname)
```

You can then perform ORA analysis on the modules in your `CEMiTool` object with the `mod_ora` function:

```{r}
# Performs over representation analysis
cem <- mod_ora(cem, gmt_in)
```

The numerical results of the analysis are stored in `cem@ora`. In order to visualise this, Use `plot_ora` to add ORA plots to your `CEMiTool` object. The `barplot_ora` slot contains for each module a list of the plots and the number of significant pathways.

```{r}
# plot ora results
cem <- plot_ora(cem)
print(cem@barplot_ora[[1]][["pl"]]) # Plot for module 1
```




## Adding interactions

When interaction data, such as protein-protein interactions, is added, `CEMiTool`



```{r}
# Reading interactions
int_fname <- system.file("extdata", "interactions.tsv", package = "CEMiTool")
int_df <- read.delim(int_fname)
```

```{r}
# adds interaction
cem <- include_interactions(cem, int_df)
```

```{r}
# plot interactions
library(ggplot2)
cem <- plot_interactions(cem)
```



















```{r, results='hide'}
# create a new CEMiTool object
cem <- new("CEMiTool", expression=expr, 
               sample_annotation=sample_annot)
```






...

```{r}
ncores <- parallel::detectCores()
doParallel::registerDoParallel(cores=ncores)
```

```{r, eval=FALSE}
# running cemitool
library(ggplot2)
cem <- cemitool(expr, sample_annot, gmt_in, interactions=int_df, 
                filter=F, plot=T, split_modules=T)
```

<!-- ```{r} generate_report(cem)```-->

```{r}
write_files(cem, directory="./reports", force=T)
```


```{r}
# create a new CEMiTool object
cem <- new("CEMiTool", expression=expr, 
               sample_annotation=sample_annot)
```

<!-- ```{r results="hide"} # generate report generate_report(cem) generate_report(cem, output_format=c("pdf_document", "html_document")) ``` -->
#Advanced

## Module analysis (overlap and mod_summary get_hubs)
